# 设计模式
Q：为什么会有设计模式？
A：设计模式是解决特定场景的抽象方法，是一种属于，模板方法

Q：设计模式的好处
A：可以一说就懂，可以简化编码复杂度，可以更好的扩展

Q：设计模式有哪些分类
A：程序一般分创建和命令，设计模式也是分为创建型、命令型、结构型。

# 创建型模式

## 工厂模式
需要有接口，通过工厂模式来实现创建不同的实现。

好处是：将构建与业务分离，比如发消息：一开始只用短信发，后来需要虚增email，
那么如果构建发送器耦合在发送的业务里，那么扩展性很差。需要工厂来实现解耦屏蔽细节。

## 抽象工厂模式 针对更多种多样的实现场景
抽象工厂用来解决正交两个维度构造的场景，例如其中一个维度是家居（桌子椅子），另一个维度是风格（北欧、韩式）。
抽象工厂是个抽象类，有其中一个维度的所有方法定义，按另一个维度有多个实现类。
好处：类似工厂模式，比工厂模式解决更复杂的构造场景。

## 生成器模式 builder 针对构建链路长的场景
例如：一个大的聚合根，每个附属实体里有多种实现。这时候聚合根需要一个factory，factory依赖builder接口，
builder中定义了buildA实体、B实体、C实体。有多个builder实现类。

## 原型模式 ProtoType
需要对象实现原型接口（实现clone方法）
使用场景：
1.类似做TEAM的统计，一次搂出所有数据后，需要按不同的规则过滤加工计算，可能会污染数据，使用原型模式进行copy。
2.初始化复杂的对象，避免频发初始化，使用原型。

## 单例 Singleton

所有单例的实现都包含以下两个相同的步骤：
将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。
新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。
此后所有对于该函数的调用都将返回这一缓存对象。

缺点：多线程需要特殊处理

# 结构型模式

## 适配器模式
解决数据、模型不兼容问题。
例如CC底层对接多个服务商，抽象出一个call的接口，通过适配器模式适配不同厂商的服务。

## 组合模式
解决模型结构嵌套的问题。
例如一个任务可能包含多个子任务，子任务下面还可能有子任务，需要计算所有的PD数，一般方法就是通过递归、查询来实现。
通过组合模式，可以让每个嵌套实现接口，返回他下面的count。

缺点：性能容易出现瓶颈

## 装饰器模式
使用场景：给功能增强，例如AOP给代码增加前后日志。 不使用继承实现，因为继承是静态的。
通过实现接口，绑定base类，增加动态增强方法。

## 外观模式
使用场景：具体实现比较复杂，通过封装一个比较好的方法、类对外提供服务，屏蔽细节。
对架构的帮助：封装细节，对上透明

## 享元模式
使用场景：需要大量实例化的对象但是内存有限，需要做动静分离。
实现方式：抽象出内在状态和外在状态，内在共享，外在分离

## 代理模式：
符合开闭原则，服务对象的控制内敛

# 行为模式
## 责任链模式
解决问题：流程长、逻辑复杂，通过链式结构进行解耦。

## 观察者模式
使用场景：状态、消息变更需要被关注，并且非主流程。

## 状态模式
适用于对象在不用状态下有不同表现的场景，需要将对象的所有状态行为抽象到一个方法里。














