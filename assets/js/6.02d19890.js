(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{58:function(a,t,n){"use strict";n.r(t);var r=n(0),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"原子操作类-java-util-concurrent-atomic"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原子操作类-java-util-concurrent-atomic","aria-hidden":"true"}},[a._v("#")]),a._v(" 原子操作类 java.util.concurrent.atomic")]),n("h2",{attrs:{id:"原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[a._v("#")]),a._v(" 原理")]),n("p",[a._v("读:volatile\n写:CAS 底层Unsafe::compareAndSwapInt实现 最底层CMPXCHG指令实现")]),n("h2",{attrs:{id:"思考-synchronized-vs-cas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思考-synchronized-vs-cas","aria-hidden":"true"}},[a._v("#")]),a._v(" 思考: Synchronized VS CAS")]),n("p",[a._v("Synchronized:1.5前阻塞同步,性能差")]),n("p",[a._v("CAS问题:ABA问题,通过版本或stamp解决,自旋时间长")]),n("h1",{attrs:{id:"同步集合类-concurrenthashmap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同步集合类-concurrenthashmap","aria-hidden":"true"}},[a._v("#")]),a._v(" 同步集合类 ConcurrentHashMap")]),n("h2",{attrs:{id:"原理-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 原理")]),n("p",[a._v("1.7ConcurrentHashMap\nSegment + HashEntry(Map) 来实现，put时第一次hash出segement->加锁 -> 第二次hash -> put HashEntry\n写分段锁 （可重入锁）实现，提升效率 16个段 ，\n读使用volatile关键字\n一些全局操作，类似contains,size会按顺序加所有锁\nSize有两种方案（三次计算内，连续2次一样，则认为准确），如果不行则顺序加锁")]),n("p",[a._v("1.8很接近hashMap，通过cas来实现并发控制\n其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树.")]),n("p",[a._v("##思考")]),n("p",[a._v("JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）\nJDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了\nJDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档\nJDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点\n因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了\nJVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然\n在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据")]),n("h1",{attrs:{id:"并行闭锁-countdownlatch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并行闭锁-countdownlatch","aria-hidden":"true"}},[a._v("#")]),a._v(" 并行闭锁 CountDownLatch")]),n("p",[a._v("##用法\n首先是创建实例 CountDownLatch countDown = new CountDownLatch(2)\n需要同步的线程执行完之后，计数-1； countDown.countDown()\n需要等待其他线程执行完毕之后，再运行的线程，调用 countDown.await()实现阻塞同步")]),n("p",[a._v("##场景\n并行操作:例如批量获取无依赖的rpc数据;并行执行同一层级操作;")]),n("p",[a._v("##原理\nAQS:AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus\nAQS结构:int state + 等待队列;当state = 0时 并发顺序唤醒所有等待队列")]),n("p",[a._v("CountDownLatch:\nawait内部实现流程:\n判断state计数是否为0，不是，则直接放过,执行主线程后面的代码\n大于0，则表示需要阻塞等待计数为0\n当前线程封装Node对象，进入阻塞队列\n然后就是循环尝试获取锁，直到成功（即state为0）后出队，继续执行线程后续代码")]),n("p",[a._v("countDown内部实现流程:\n1.尝试释放锁tryReleaseShared，实现计数-1\n若计数已经小于0，则直接返回false\n否则执行计数(AQS的state)减一\n若减完之后，state==0，表示没有线程占用锁，即释放成功，然后就需要唤醒被阻塞的线程了\n2.释放并唤醒阻塞线程 doReleaseShared\n如果队列为空，即表示没有线程被阻塞（也就是说没有线程调用了 CountDownLatch#wait()方法），直接退出\n头结点如果为SIGNAL, 则依次唤醒头结点下个节点上关联的线程，并出队")]),n("h1",{attrs:{id:"cyclicbarrier"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier","aria-hidden":"true"}},[a._v("#")]),a._v(" CyclicBarrier")]),n("h2",{attrs:{id:"结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 结构")]),n("p",[a._v("int parties 拦截,等待的线程数 final\nint count 计数器,每个线程await count--\nGeneration{boolean broken = false;} 实现循环,实现是否停止\nrunnable barrierCommand nextGeneration之前执行的任务")]),n("h2",{attrs:{id:"过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#过程","aria-hidden":"true"}},[a._v("#")]),a._v(" 过程")]),n("p",[a._v("初始化CyclicBarrier\n每个线程await count--\ncount = 0时换代,执行barrierCommand\n唤醒所有await线程")]),n("h2",{attrs:{id:"原理-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理-3","aria-hidden":"true"}},[a._v("#")]),a._v(" 原理")]),n("p",[a._v("await 先通过ReentrantLock加锁实现同步,后续通过Condition进行await和signalAll操作")]),n("h1",{attrs:{id:"线程池"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程池")]),n("h2",{attrs:{id:"背景-池-的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景-池-的作用","aria-hidden":"true"}},[a._v("#")]),a._v(' 背景 - "池"的作用')]),n("p",[a._v("1.复用已有资源\n2.控制资源总量")]),n("h2",{attrs:{id:"结构-配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结构-配置","aria-hidden":"true"}},[a._v("#")]),a._v(" 结构,配置")]),n("p",[a._v("核心线程数:有任务来,当前线程数<core,则新建线程\n最大线程数:等待队列满时,有新的任务且 当前线程<max,则新建线程\n等待队列: 有界,无界,同步递交\n拒绝策略: 直接拒绝,丢弃新任务,丢弃旧任务,交给提交方主线程执行\n保持时间: 超过alive时间,超过核心线程数的线程将销毁,可以开启核心线程也自动销毁的检测")]),n("h2",{attrs:{id:"如何调优"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何调优","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何调优")]),n("p",[a._v("任务分类: CPU密集型 IO密集型 混合型\nCPU密集型:线程数 = cpu数+1\nIO密集型:线程数尽可能多,因为需要等待IO,大多数rpc请求应该都属于此类\n混合型: 任务拆解")])])}],!1,null,null,null);t.default=e.exports}}]);